package com.aplayer.hardwareencode;import android.media.MediaCodec;import android.media.MediaFormat;import com.aplayer.aplayerandroid.Log;import com.aplayer.hardwareencode.module.EncoderConstant;import com.aplayer.hardwareencode.module.RawFrame;import java.util.LinkedList;import java.util.List;import java.util.Queue;import static android.content.ContentValues.TAG;import static com.aplayer.hardwareencode.module.EncoderConstant.QUEUE_FULL;import static com.aplayer.hardwareencode.module.EncoderConstant.SUCCESS;/** * Created by LZ on 2016/10/18. */public abstract class EncoderBase extends Thread {    abstract boolean init();    abstract void    release();    abstract boolean feedRawData(byte[] input, long pts, long timeoutUs);    abstract List<EncodeFrame> fetchEncodeData();    abstract MediaFormat getMediaFormat();    private     Queue<RawFrame> mRawFrameQueue = new LinkedList<RawFrame>();    protected HardwareEncoder mHardwareEncoder = null;    protected   boolean         mRunning = false;    protected   int             mMaxInputQueueSize = 5;    public EncoderBase(HardwareEncoder hardwareEncoder){        mHardwareEncoder = hardwareEncoder;    }    public int feedRewData(RawFrame  rawFrame){        synchronized (mRawFrameQueue) {            Log.i(TAG,"putRawData feedRewData");            if(mRawFrameQueue.size() >= mMaxInputQueueSize)            {                return QUEUE_FULL;            }            else            {                mRawFrameQueue.add(rawFrame);            }        }        return SUCCESS;    }    public void stopEncode(){        mRunning = false;        synchronized (mRawFrameQueue){            mRawFrameQueue.clear();            try {                this.join();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        release();    }    @SuppressWarnings("finally")    @Override    public void run(){        while (mRunning){            if(mRawFrameQueue.isEmpty()){                try {                    Thread.sleep(EncoderConstant.THREAD_CHECK_INTERVAL_MS);                } catch (InterruptedException e) {                    e.printStackTrace();                }                finally {                    continue;                }            }            RawFrame rawFrame = null;            synchronized (mRawFrameQueue){                rawFrame = mRawFrameQueue.remove();            }            if(null != rawFrame && null != rawFrame.rawData && !feedRawData(rawFrame.rawData, rawFrame.pts, -1)){                Log.e(TAG, "feed raw data failed!");            }            List<EncoderBase.EncodeFrame> encodeFrames = fetchEncodeData();            mHardwareEncoder.putEncoderData(this,encodeFrames);        }    }    public class EncodeFrame{        public EncodeFrame(byte[] buff, MediaCodec.BufferInfo   buffInfo, MediaFormat newFormat) {            this.buff       = buff;            this.buffInfo   = buffInfo;            this.newFormat  = newFormat;        }        public byte[]                   buff;        public MediaCodec.BufferInfo    buffInfo;        public MediaFormat              newFormat;    }}